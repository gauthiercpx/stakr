name: Build and Deploy to Azure Container Apps

on:
  push:
    branches: ["master"]
  workflow_dispatch:

permissions:
  contents: read

env:
  RESOURCE_GROUP: rg-stakr-prod
  CONTAINER_APP_NAME: stakr-backend
  CONTAINER_ENV: env-stakr
  IMAGE_NAME: stakr-backend

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Log in to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: |
            ${{ secrets.AZURE_CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
            ${{ secrets.AZURE_CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:latest

      - name: Deploy (migrate then update)
        shell: bash
        run: |
          set -euo pipefail

          IMAGE="${{ secrets.AZURE_CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          echo "Image: ${IMAGE}"

          az version

          # Container Apps CLI extension (preview required)
          az extension add --name containerapp --version 0.3.53 --upgrade --yes

          # Ensure the Container App exists (create once)
          if ! az containerapp show --name "${{ env.CONTAINER_APP_NAME }}" --resource-group "${{ env.RESOURCE_GROUP }}" --only-show-errors 1>/dev/null; then
            az containerapp create \
              --name "${{ env.CONTAINER_APP_NAME }}" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --environment "${{ env.CONTAINER_ENV }}" \
              --image "${IMAGE}" \
              --registry-server "${{ secrets.AZURE_CONTAINER_REGISTRY }}" \
              --registry-username "${{ secrets.REGISTRY_USERNAME }}" \
              --registry-password "${{ secrets.REGISTRY_PASSWORD }}" \
              --ingress external \
              --target-port 8000 \
              --only-show-errors
          fi

          # --- Migrations ---
          # `az containerapp exec` requires at least 1 running replica.
          echo "Ensuring at least one running replica for migrations..."
          az containerapp update \
            --name "${{ env.CONTAINER_APP_NAME }}" \
            --resource-group "${{ env.RESOURCE_GROUP }}" \
            --min-replicas 1 \
            --only-show-errors

          echo "Waiting for a healthy replica..."
          for i in {1..60}; do
            READY_COUNT=$(az containerapp replica list \
              --name "${{ env.CONTAINER_APP_NAME }}" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --query "[?properties.runningState=='Running' && properties.healthState=='Healthy'] | length(@)" \
              -o tsv 2>/dev/null || echo 0)

            if [ "${READY_COUNT:-0}" -ge 1 ]; then
              echo "Replica is running and healthy."
              break
            fi

            echo "Not ready yet (${i}/60). Sleeping 5s..."
            sleep 5
          done

          if [ "${READY_COUNT:-0}" -lt 1 ]; then
            echo "ERROR: No healthy replica found after waiting."
            az containerapp replica list --name "${{ env.CONTAINER_APP_NAME }}" --resource-group "${{ env.RESOURCE_GROUP }}" -o table || true
            exit 3
          fi

          echo "Running Alembic migrations (in-app exec)..."
          # `az containerapp exec` may require a TTY (and CI runners don't provide one by default).
          # `script` allocates a pseudo-TTY so the command can run non-interactively.
          script -q -e -c "az containerapp exec --name '${{ env.CONTAINER_APP_NAME }}' --resource-group '${{ env.RESOURCE_GROUP }}' --command 'python -m alembic upgrade head' --only-show-errors" /dev/null

          # --- Deploy app ---
          az containerapp update \
            --name "${{ env.CONTAINER_APP_NAME }}" \
            --resource-group "${{ env.RESOURCE_GROUP }}" \
            --image "${IMAGE}" \
            --only-show-errors

          FQDN=$(az containerapp show \
            --name "${{ env.CONTAINER_APP_NAME }}" \
            --resource-group "${{ env.RESOURCE_GROUP }}" \
            --query properties.configuration.ingress.fqdn -o tsv)

          echo "Deployed: https://${FQDN}"
